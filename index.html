<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>EventPad MVP</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    
    :root {
      --bg: #0f0f13;
      --surface: #1a1a24;
      --surface-hover: #252532;
      --border: #2a2a3a;
      --text: #ffffff;
      --text-muted: #888;
      --event: #ff9d48;
      --command: #4a90d9;
      --readmodel: #8bc34a;
      --screen: #e0e0e0;
      --processor: #9c27b0;
      --accent: #9b59b6;
    }
    
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: var(--bg);
      color: var(--text);
      min-height: 100vh;
      padding-bottom: 80px;
    }
    
    /* Header */
    .header {
      position: sticky;
      top: 0;
      background: var(--surface);
      padding: 12px 20px;
      border-bottom: 1px solid var(--border);
      z-index: 100;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .header h1 { font-size: 18px; font-weight: 600; }
    .header-actions { display: flex; gap: 8px; }
    .header-btn {
      background: var(--surface-hover);
      border: 1px solid var(--border);
      color: var(--text);
      padding: 6px 12px;
      border-radius: 6px;
      font-size: 12px;
      cursor: pointer;
    }
    .header-btn:hover { background: var(--accent); border-color: var(--accent); }
    .header-btn:disabled { opacity: 0.3; cursor: not-allowed; }
    
    /* Event Log Toggle */
    .event-log-toggle {
      position: fixed;
      top: 60px;
      right: 16px;
      background: var(--surface);
      border: 1px solid var(--border);
      padding: 8px 12px;
      border-radius: 8px;
      font-size: 11px;
      color: var(--text-muted);
      cursor: pointer;
      z-index: 99;
    }
    
    /* Event Log Panel */
    .event-log {
      display: none;
      position: fixed;
      top: 100px;
      right: 16px;
      width: 320px;
      max-height: 60vh;
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 12px;
      overflow: hidden;
      z-index: 98;
    }
    .event-log.visible { display: block; }
    .event-log-header {
      padding: 12px;
      background: var(--bg);
      font-weight: 600;
      font-size: 13px;
      border-bottom: 1px solid var(--border);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .event-log-list {
      max-height: 50vh;
      overflow-y: auto;
      font-size: 11px;
      font-family: 'Monaco', 'Menlo', monospace;
    }
    .event-log-item {
      padding: 8px 12px;
      border-bottom: 1px solid var(--border);
      cursor: pointer;
      transition: background 0.2s;
    }
    .event-log-item:hover { background: var(--surface-hover); }
    .event-log-item:active { background: var(--accent); }
    .event-log-item:last-child { border-bottom: none; }
    .event-log-item .copied {
      color: var(--accent);
      font-size: 10px;
      margin-left: 8px;
    }
    .event-log-type { color: var(--event); font-weight: 600; }
    .event-log-data { color: var(--text-muted); margin-top: 4px; white-space: pre-wrap; word-break: break-all; }
    .event-log-time { color: var(--text-muted); font-size: 10px; }
    
    /* Feed */
    .feed {
      padding: 16px;
      padding-top: 8px;
      display: flex;
      flex-direction: column;
      gap: 16px;
    }
    
    /* Element Card */
    .element-card {
      background: var(--surface);
      border-radius: 12px;
      overflow: hidden;
      border: 1px solid var(--border);
    }
    
    .element-header {
      display: flex;
      align-items: center;
      padding: 14px 16px;
      gap: 12px;
      cursor: pointer;
    }
    .element-header:hover { background: var(--surface-hover); }
    
    .element-icon {
      width: 36px;
      height: 36px;
      border-radius: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 18px;
      flex-shrink: 0;
    }
    .element-icon.event { background: var(--event); color: #000; }
    .element-icon.command { background: var(--command); color: #fff; }
    .element-icon.readModel { background: var(--readmodel); color: #000; }
    .element-icon.screen { background: var(--screen); color: #000; }
    .element-icon.processor { background: var(--processor); color: #fff; }
    
    .element-info { flex: 1; }
    .element-name { font-weight: 600; font-size: 15px; }
    .element-type { font-size: 12px; color: var(--text-muted); }
    
    .element-chevron {
      color: var(--text-muted);
      transition: transform 0.2s;
    }
    .element-card.expanded .element-chevron { transform: rotate(180deg); }
    
    /* Connections */
    .element-connections {
      padding: 0 16px 12px;
      font-size: 12px;
    }
    .connection-item {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 6px 10px;
      background: var(--bg);
      border-radius: 8px;
      margin-bottom: 6px;
    }
    .connection-icon {
      width: 20px;
      height: 20px;
      border-radius: 4px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 11px;
    }
    .connection-label {
      color: var(--text-muted);
      font-size: 11px;
    }
    .connection-name {
      color: var(--text);
    }

    /* Properties */
    .element-properties {
      display: none;
      padding: 0 16px 12px;
      font-size: 13px;
    }
    .element-card.expanded .element-properties { display: block; }
    .property {
      padding: 6px 0;
      color: var(--text-muted);
      border-bottom: 1px solid var(--border);
    }
    .property:last-child { border-bottom: none; }
    .add-property {
      color: var(--accent);
      padding: 8px 0;
      cursor: pointer;
    }
    
    /* Actions */
    .element-actions {
      display: none;
      padding: 12px 16px;
      background: var(--bg);
      border-top: 1px solid var(--border);
      gap: 8px;
      flex-wrap: wrap;
    }
    .element-card.expanded .element-actions { display: flex; }
    
    .action-btn {
      background: var(--surface-hover);
      border: 1px solid var(--border);
      color: var(--text);
      padding: 10px 14px;
      border-radius: 20px;
      font-size: 13px;
      cursor: pointer;
      white-space: nowrap;
    }
    .action-btn:hover { background: var(--accent); border-color: var(--accent); }
    
    /* Slice Card */
    .slice-card {
      background: var(--surface);
      border-radius: 12px;
      border: 2px solid var(--accent);
      overflow: hidden;
    }
    .slice-header {
      background: var(--accent);
      color: white;
      padding: 12px 16px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .slice-name { font-weight: 600; font-size: 15px; }
    .slice-type {
      font-size: 11px;
      background: rgba(255,255,255,0.2);
      padding: 3px 8px;
      border-radius: 10px;
    }
    .slice-elements { padding: 12px; }
    .slice-element {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 8px 0;
    }
    .slice-element-icon {
      width: 28px;
      height: 28px;
      border-radius: 6px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
    }
    .slice-arrow {
      text-align: center;
      color: var(--text-muted);
      font-size: 12px;
      padding: 4px 0;
    }
    
    /* Scenarios */
    .scenarios {
      border-top: 1px solid var(--border);
      padding: 12px;
    }
    .scenario {
      background: var(--bg);
      border-radius: 8px;
      padding: 12px;
      margin-bottom: 8px;
      font-size: 13px;
    }
    .scenario-name {
      font-weight: 600;
      margin-bottom: 8px;
      display: flex;
      align-items: center;
      gap: 6px;
    }
    .scenario-name.success { color: #4caf50; }
    .scenario-line {
      color: var(--text-muted);
      padding: 2px 0;
      font-family: monospace;
      font-size: 12px;
    }
    .add-scenario {
      color: var(--accent);
      padding: 8px;
      cursor: pointer;
      text-align: center;
      font-size: 13px;
    }
    
    /* FAB */
    .fab {
      position: fixed;
      bottom: 24px;
      right: 24px;
      width: 56px;
      height: 56px;
      background: var(--accent);
      border-radius: 28px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 28px;
      color: white;
      cursor: pointer;
      box-shadow: 0 4px 12px rgba(0,0,0,0.4);
      z-index: 200;
    }
    .fab:hover { transform: scale(1.05); }
    
    /* Bottom Sheet */
    .sheet-overlay {
      display: none;
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.6);
      z-index: 300;
    }
    .sheet-overlay.active { display: block; }
    
    .sheet {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      background: var(--surface);
      border-radius: 20px 20px 0 0;
      padding: 20px;
      transform: translateY(100%);
      transition: transform 0.3s ease;
      z-index: 301;
      max-height: 80vh;
      overflow-y: auto;
    }
    .sheet-overlay.active .sheet { transform: translateY(0); }
    
    .sheet-handle {
      width: 40px;
      height: 4px;
      background: var(--border);
      border-radius: 2px;
      margin: 0 auto 16px;
    }
    .sheet-title {
      font-size: 18px;
      font-weight: 600;
      margin-bottom: 16px;
    }
    
    .sheet-options {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    .sheet-option {
      display: flex;
      align-items: center;
      gap: 14px;
      padding: 14px;
      background: var(--bg);
      border-radius: 12px;
      cursor: pointer;
    }
    .sheet-option:hover { background: var(--surface-hover); }
    .sheet-option-icon {
      width: 44px;
      height: 44px;
      border-radius: 10px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 20px;
    }
    .sheet-option-text { flex: 1; }
    .sheet-option-title { font-weight: 500; margin-bottom: 2px; }
    .sheet-option-desc { font-size: 12px; color: var(--text-muted); }
    
    .sheet-input {
      width: 100%;
      background: var(--bg);
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 14px;
      color: var(--text);
      font-size: 16px;
      margin-bottom: 16px;
    }
    .sheet-input:focus { outline: none; border-color: var(--accent); }
    .sheet-btn {
      width: 100%;
      background: var(--accent);
      color: white;
      border: none;
      padding: 14px;
      border-radius: 10px;
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
    }
    
    /* Toast */
    .toast {
      position: fixed;
      bottom: 100px;
      left: 50%;
      transform: translateX(-50%) translateY(100px);
      background: var(--surface);
      border: 1px solid var(--accent);
      padding: 12px 20px;
      border-radius: 25px;
      font-size: 14px;
      opacity: 0;
      transition: all 0.3s;
      z-index: 400;
    }
    .toast.show { transform: translateX(-50%) translateY(0); opacity: 1; }
    
    /* Empty State */
    .empty-state {
      text-align: center;
      padding: 60px 20px;
      color: var(--text-muted);
    }
    .empty-state-icon { font-size: 48px; margin-bottom: 16px; }
    .empty-state-text { font-size: 15px; }
  </style>
</head>
<body>
  <div class="header">
    <h1>EventPad</h1>
    <div class="header-actions">
      <button class="header-btn" id="undoBtn" onclick="undo()" disabled>‚Ü∂ Undo</button>
      <button class="header-btn" onclick="clearAll()">Clear</button>
    </div>
  </div>

  <div class="event-log-toggle" onclick="toggleEventLog()">
    üìã Events (<span id="eventCount">0</span>)
  </div>
  
  <div class="event-log" id="eventLog">
    <div class="event-log-header">
      <span>Event Stream</span>
      <button class="header-btn" onclick="copyAllEvents()" style="padding: 4px 8px; font-size: 11px;">Copy All</button>
    </div>
    <div class="event-log-list" id="eventLogList"></div>
  </div>

  <div class="feed" id="feed">
    <div class="empty-state" id="emptyState">
      <div class="empty-state-icon">üüß</div>
      <div class="empty-state-text">Tap + to create your first element</div>
    </div>
  </div>

  <div class="fab" id="fab">+</div>

  <!-- Create Element Sheet -->
  <div class="sheet-overlay" id="createSheet">
    <div class="sheet">
      <div class="sheet-handle"></div>
      <div class="sheet-title">Create Element</div>
      <div class="sheet-options">
        <div class="sheet-option" onclick="selectType('event')">
          <div class="sheet-option-icon" style="background: var(--event); color: #000;">üüß</div>
          <div class="sheet-option-text">
            <div class="sheet-option-title">Event</div>
            <div class="sheet-option-desc">Something that happened</div>
          </div>
        </div>
        <div class="sheet-option" onclick="selectType('command')">
          <div class="sheet-option-icon" style="background: var(--command); color: #fff;">üü¶</div>
          <div class="sheet-option-text">
            <div class="sheet-option-title">Command</div>
            <div class="sheet-option-desc">An action to perform</div>
          </div>
        </div>
        <div class="sheet-option" onclick="selectType('readModel')">
          <div class="sheet-option-icon" style="background: var(--readmodel); color: #000;">üü©</div>
          <div class="sheet-option-text">
            <div class="sheet-option-title">Read Model</div>
            <div class="sheet-option-desc">Data for display</div>
          </div>
        </div>
        <div class="sheet-option" onclick="selectType('screen')">
          <div class="sheet-option-icon" style="background: var(--screen); color: #000;">‚èπÔ∏è</div>
          <div class="sheet-option-text">
            <div class="sheet-option-title">Screen</div>
            <div class="sheet-option-desc">User interface</div>
          </div>
        </div>
        <div class="sheet-option" onclick="selectType('processor')">
          <div class="sheet-option-icon" style="background: var(--processor); color: #fff;">‚öôÔ∏è</div>
          <div class="sheet-option-text">
            <div class="sheet-option-title">Processor</div>
            <div class="sheet-option-desc">Automation logic</div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Name Element Sheet -->
  <div class="sheet-overlay" id="nameSheet">
    <div class="sheet">
      <div class="sheet-handle"></div>
      <div class="sheet-title" id="nameSheetTitle">Name your Event</div>
      <input type="text" class="sheet-input" id="elementNameInput" placeholder="e.g. OrderCreated">
      <button class="sheet-btn" onclick="dispatchCreateElement()">Create</button>
    </div>
  </div>

  <!-- Action Sheet -->
  <div class="sheet-overlay" id="actionSheet">
    <div class="sheet">
      <div class="sheet-handle"></div>
      <div class="sheet-title" id="actionSheetTitle">Connect Element</div>
      <div class="sheet-options" id="actionOptions"></div>
    </div>
  </div>

  <!-- Name Slice Sheet -->
  <div class="sheet-overlay" id="sliceNameSheet">
    <div class="sheet">
      <div class="sheet-handle"></div>
      <div class="sheet-title">üéâ Pattern detected!</div>
      <p style="color: var(--text-muted); margin-bottom: 16px; font-size: 14px;" id="slicePatternDesc"></p>
      <input type="text" class="sheet-input" id="sliceNameInput" placeholder="e.g. Create Order">
      <button class="sheet-btn" onclick="dispatchNameSlice()">Save Slice</button>
      <div style="text-align: center; padding: 12px; color: var(--text-muted); cursor: pointer;" onclick="dismissSlicePrompt()">Skip for now</div>
    </div>
  </div>

  <div class="toast" id="toast"></div>

  <script>
    // ===========================================
    // EVENT STORE
    // ===========================================
    
    const EventTypes = {
      // Element events
      ElementCreated: 'ElementCreated',
      ElementDeleted: 'ElementDeleted',
      PropertyAdded: 'PropertyAdded',
      PropertyRemoved: 'PropertyRemoved',
      
      // Connection events
      ProducerSet: 'ProducerSet',
      ConsumerAdded: 'ConsumerAdded',
      TriggerSet: 'TriggerSet',
      ProcessorOutputSet: 'ProcessorOutputSet',
      InputScreenSet: 'InputScreenSet',
      DisplayScreenSet: 'DisplayScreenSet',
      
      // Slice events
      SliceInferred: 'SliceInferred',
      SliceNamed: 'SliceNamed',
      SliceDeleted: 'SliceDeleted',
      
      // Scenario events
      ScenarioAdded: 'ScenarioAdded',
      GivenSet: 'GivenSet',
      WhenSet: 'WhenSet',
      ThenSet: 'ThenSet'
    };

    // Event stream (source of truth)
    let eventStream = [];
    
    // Load from localStorage
    function loadEventStream() {
      const saved = localStorage.getItem('eventpad_events');
      if (saved) {
        eventStream = JSON.parse(saved);
      }
    }
    
    // Save to localStorage
    function saveEventStream() {
      localStorage.setItem('eventpad_events', JSON.stringify(eventStream));
    }
    
    // Append event to stream
    function appendEvent(type, data) {
      const event = {
        id: 'evt_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9),
        type,
        data,
        timestamp: new Date().toISOString()
      };
      eventStream.push(event);
      saveEventStream();
      console.log('üìå Event:', type, data);
      return event;
    }

    // ===========================================
    // PROJECTIONS (Read Models)
    // ===========================================
    
    function projectState() {
      const state = {
        elements: {},      // id -> element
        slices: {},        // id -> slice
        connections: [],   // { from, to, relation }
        pendingSlice: null
      };

      for (const event of eventStream) {
        switch (event.type) {
          case EventTypes.ElementCreated:
            state.elements[event.data.elementId] = {
              id: event.data.elementId,
              type: event.data.elementType,
              name: event.data.name,
              properties: []
            };
            break;
            
          case EventTypes.ElementDeleted:
            delete state.elements[event.data.elementId];
            break;
            
          case EventTypes.PropertyAdded:
            if (state.elements[event.data.elementId]) {
              state.elements[event.data.elementId].properties.push({
                id: event.data.propertyId,
                name: event.data.name,
                type: event.data.propertyType
              });
            }
            break;
            
          case EventTypes.ProducerSet:
          case EventTypes.ConsumerAdded:
          case EventTypes.TriggerSet:
          case EventTypes.ProcessorOutputSet:
          case EventTypes.InputScreenSet:
          case EventTypes.DisplayScreenSet:
            state.connections.push({
              from: event.data.fromId,
              to: event.data.toId,
              relation: event.data.relation
            });
            break;
            
          case EventTypes.SliceInferred:
            state.slices[event.data.sliceId] = {
              id: event.data.sliceId,
              type: event.data.sliceType,
              elements: event.data.elements,
              name: null,
              complete: event.data.complete
            };
            if (!event.data.complete || !state.slices[event.data.sliceId].name) {
              state.pendingSlice = event.data.sliceId;
            }
            break;
            
          case EventTypes.SliceNamed:
            if (state.slices[event.data.sliceId]) {
              state.slices[event.data.sliceId].name = event.data.name;
              if (state.pendingSlice === event.data.sliceId) {
                state.pendingSlice = null;
              }
            }
            break;
          
          case 'SliceElementAdded':
            if (state.slices[event.data.sliceId]) {
              const slice = state.slices[event.data.sliceId];
              // Insert at position based on element type
              if (event.data.position === 'start') {
                slice.elements.unshift(event.data.elementId);
              } else if (event.data.position === 'afterCommand') {
                // Find command and insert after it
                const cmdIndex = slice.elements.findIndex(id => 
                  state.elements[id]?.type === 'command'
                );
                if (cmdIndex >= 0) {
                  slice.elements.splice(cmdIndex + 1, 0, event.data.elementId);
                } else {
                  slice.elements.push(event.data.elementId);
                }
              } else {
                slice.elements.push(event.data.elementId);
              }
            }
            break;
            
          case EventTypes.SliceDeleted:
            delete state.slices[event.data.sliceId];
            break;
        }
      }

      return state;
    }

    // ===========================================
    // COMMAND HANDLERS
    // ===========================================
    
    let selectedType = null;
    let selectedElement = null;
    let pendingSliceId = null;

    const typeIcons = {
      event: 'üüß', command: 'üü¶', readModel: 'üü©', screen: '‚èπÔ∏è', processor: '‚öôÔ∏è'
    };
    const typeLabels = {
      event: 'Event', command: 'Command', readModel: 'Read Model', screen: 'Screen', processor: 'Processor'
    };

    const elementActions = {
      event: [
        { label: 'What produces this?', target: 'command', relation: 'producer', sliceType: 'SC' },
        { label: 'What does this update?', target: 'readModel', relation: 'consumer', sliceType: 'SV' },
        { label: 'What does this trigger?', target: 'processor', relation: 'trigger', sliceType: 'AU' }
      ],
      command: [
        { label: 'What screen triggers this?', target: 'screen', relation: 'input' },
        { label: 'What events does this produce?', target: 'event', relation: 'produces', sliceType: 'SC' }
      ],
      readModel: [
        { label: 'What events update this?', target: 'event', relation: 'updatedBy' },
        { label: 'What screen displays this?', target: 'screen', relation: 'display' }
      ],
      processor: [
        { label: 'What command does this invoke?', target: 'command', relation: 'invokes' },
        { label: 'What context does this need?', target: 'readModel', relation: 'context' }
      ],
      screen: [
        { label: 'What command does this trigger?', target: 'command', relation: 'triggers' },
        { label: 'What does this display?', target: 'readModel', relation: 'displays' }
      ]
    };

    function dispatchCreateElement() {
      const name = document.getElementById('elementNameInput').value.trim();
      if (!name) return;

      const elementId = 'el_' + Date.now();
      
      // Emit event
      appendEvent(EventTypes.ElementCreated, {
        elementId,
        elementType: selectedType,
        name
      });

      hideAllSheets();
      showToast(`${typeLabels[selectedType]} created!`);
      render();
    }

    function dispatchConnection(relation, targetType, sliceType) {
      hideAllSheets();
      
      const name = prompt(`Name the ${typeLabels[targetType]}:`);
      if (!name) return;

      const newElementId = 'el_' + Date.now();
      
      // 1. Create the new element
      appendEvent(EventTypes.ElementCreated, {
        elementId: newElementId,
        elementType: targetType,
        name
      });

      // 2. Create connection
      const fromId = (relation === 'producer' || relation === 'trigger') ? newElementId : selectedElement.id;
      const toId = (relation === 'producer' || relation === 'trigger') ? selectedElement.id : newElementId;
      
      appendEvent(EventTypes.ProducerSet, {
        fromId,
        toId,
        relation
      });

      // 3. Check if selected element is already in a slice
      const state = projectState();
      console.log('Looking for element in slice:', selectedElement.id);
      console.log('All slices:', state.slices);
      
      const existingSlice = Object.values(state.slices).find(s => {
        console.log('Checking slice:', s.id, 'elements:', s.elements);
        return s.elements.includes(selectedElement.id);
      });
      
      console.log('Found existingSlice:', existingSlice);
      
      if (existingSlice) {
        // Add new element to existing slice
        let position = 'end';
        
        // Screens go at start (input) or end (display)
        if (targetType === 'screen' && relation === 'input') {
          position = 'start';
        } else if (targetType === 'readModel') {
          position = 'end';
        } else if (targetType === 'event' && relation === 'produces') {
          // Find position after command
          const cmdIndex = existingSlice.elements.findIndex(id => 
            state.elements[id]?.type === 'command'
          );
          position = cmdIndex >= 0 ? 'afterCommand' : 'end';
        }
        
        appendEvent('SliceElementAdded', {
          sliceId: existingSlice.id,
          elementId: newElementId,
          position
        });
        
        showToast('Added to slice!');
      } else if (sliceType) {
        // 4. Infer new slice if pattern detected
        const sliceId = 'slice_' + Date.now();
        let elements = [];
        
        if (sliceType === 'SC') {
          // SC: command -> event (order matters for display)
          if (relation === 'producer') {
            // Event asked "what produces this?" ‚Üí new command, then event
            elements = [newElementId, selectedElement.id];
          } else if (relation === 'produces') {
            // Command asked "what does this produce?" ‚Üí command, then new event
            elements = [selectedElement.id, newElementId];
          } else {
            elements = [newElementId, selectedElement.id];
          }
        } else if (sliceType === 'SV') {
          elements = [selectedElement.id, newElementId]; // event -> readModel
        } else if (sliceType === 'AU') {
          elements = [selectedElement.id, newElementId]; // event -> processor
        }

        appendEvent(EventTypes.SliceInferred, {
          sliceId,
          sliceType,
          elements,
          complete: sliceType !== 'AU' // AU needs more elements
        });

        pendingSliceId = sliceId;
        
        // Show naming prompt
        document.getElementById('slicePatternDesc').textContent = 
          sliceType === 'SC' ? 'Command ‚Üí Event forms a State Change slice' :
          sliceType === 'SV' ? 'Event ‚Üí Read Model forms a State View slice' :
          'Event ‚Üí Processor starts an Automation slice';
        document.getElementById('sliceNameInput').value = '';
        
        setTimeout(() => {
          showSheet('sliceNameSheet');
          setTimeout(() => document.getElementById('sliceNameInput').focus(), 300);
        }, 300);
      }

      showToast(`${typeLabels[targetType]} connected!`);
      render();
    }

    function dispatchNameSlice() {
      const name = document.getElementById('sliceNameInput').value.trim();
      if (!name || !pendingSliceId) return;

      appendEvent(EventTypes.SliceNamed, {
        sliceId: pendingSliceId,
        name
      });

      pendingSliceId = null;
      hideAllSheets();
      showToast('Slice saved! üéâ');
      render();
    }

    function undo() {
      if (eventStream.length === 0) return;
      eventStream.pop();
      saveEventStream();
      render();
      showToast('Undone');
    }

    function clearAll() {
      if (!confirm('Clear all events?')) return;
      eventStream = [];
      saveEventStream();
      render();
      showToast('Cleared');
    }

    // ===========================================
    // UI HELPERS
    // ===========================================
    
    function showSheet(id) {
      document.getElementById(id).classList.add('active');
    }

    function hideSheet(id) {
      document.getElementById(id).classList.remove('active');
    }

    function hideAllSheets() {
      document.querySelectorAll('.sheet-overlay').forEach(s => s.classList.remove('active'));
    }

    function showToast(message) {
      const toast = document.getElementById('toast');
      toast.textContent = message;
      toast.classList.add('show');
      setTimeout(() => toast.classList.remove('show'), 2500);
    }

    function toggleEventLog() {
      document.getElementById('eventLog').classList.toggle('visible');
    }

    async function copyEvent(index, element) {
      const evt = eventStream[index];
      const text = JSON.stringify(evt, null, 2);
      
      try {
        await navigator.clipboard.writeText(text);
        
        // Show feedback
        const existing = element.querySelector('.copied');
        if (existing) existing.remove();
        
        const badge = document.createElement('span');
        badge.className = 'copied';
        badge.textContent = '‚úì copied';
        element.querySelector('.event-log-type').after(badge);
        
        setTimeout(() => badge.remove(), 1500);
      } catch (err) {
        showToast('Failed to copy');
      }
    }
    
    async function copyAllEvents() {
      const text = JSON.stringify(eventStream, null, 2);
      try {
        await navigator.clipboard.writeText(text);
        showToast('All events copied!');
      } catch (err) {
        showToast('Failed to copy');
      }
    }

    function selectType(type) {
      selectedType = type;
      hideSheet('createSheet');
      document.getElementById('nameSheetTitle').textContent = `Name your ${typeLabels[type]}`;
      document.getElementById('elementNameInput').value = '';
      showSheet('nameSheet');
      setTimeout(() => document.getElementById('elementNameInput').focus(), 300);
    }

    function toggleElement(id) {
      const card = document.querySelector(`[data-id="${id}"]`);
      card.classList.toggle('expanded');
    }

    function showActions(id, e) {
      e.stopPropagation();
      const state = projectState();
      selectedElement = state.elements[id];
      const actions = elementActions[selectedElement.type];
      
      document.getElementById('actionSheetTitle').textContent = selectedElement.name;
      document.getElementById('actionOptions').innerHTML = actions.map(action => `
        <div class="sheet-option" onclick="dispatchConnection('${action.relation}', '${action.target}', '${action.sliceType || ''}')">
          <div class="sheet-option-icon" style="background: var(--${action.target}); color: ${action.target === 'command' || action.target === 'processor' ? '#fff' : '#000'};">${typeIcons[action.target]}</div>
          <div class="sheet-option-text">
            <div class="sheet-option-title">${action.label}</div>
            <div class="sheet-option-desc">Connect to ${typeLabels[action.target]}</div>
          </div>
        </div>
      `).join('');
      
      showSheet('actionSheet');
    }

    function dismissSlicePrompt() {
      pendingSliceId = null;
      hideAllSheets();
    }

    // ===========================================
    // RENDER
    // ===========================================
    
    function render() {
      const state = projectState();
      const feed = document.getElementById('feed');
      
      // Update event count
      document.getElementById('eventCount').textContent = eventStream.length;
      document.getElementById('undoBtn').disabled = eventStream.length === 0;
      
      // Update event log
      document.getElementById('eventLogList').innerHTML = eventStream.slice().reverse().map((evt, i) => `
        <div class="event-log-item" onclick="copyEvent(${eventStream.length - 1 - i}, this)">
          <span class="event-log-type">${evt.type}</span>
          <span class="event-log-time">${new Date(evt.timestamp).toLocaleTimeString()}</span>
          <div class="event-log-data">${JSON.stringify(evt.data, null, 2)}</div>
        </div>
      `).join('');

      const elements = Object.values(state.elements);
      const slices = Object.values(state.slices).filter(s => s.name); // Only named slices
      
      document.getElementById('emptyState').style.display = elements.length ? 'none' : 'block';

      // Get elements that are in named slices
      const slicedElementIds = new Set(slices.flatMap(s => s.elements));

      // Render slices
      let html = slices.map(slice => {
        const sliceElements = slice.elements.map(id => state.elements[id]).filter(Boolean);
        const cmdEl = sliceElements.find(e => e.type === 'command');
        const evtEl = sliceElements.find(e => e.type === 'event');
        const rmEl = sliceElements.find(e => e.type === 'readModel');
        
        return `
          <div class="slice-card">
            <div class="slice-header">
              <span class="slice-name">${slice.name}</span>
              <span class="slice-type">${slice.type}</span>
            </div>
            <div class="slice-elements">
              ${sliceElements.map((el, i) => `
                ${i > 0 ? '<div class="slice-arrow">‚Üì</div>' : ''}
                <div class="slice-element">
                  <div class="slice-element-icon" style="background: var(--${el.type}); color: ${el.type === 'command' || el.type === 'processor' ? '#fff' : '#000'};">${typeIcons[el.type]}</div>
                  <span>${el.name}</span>
                </div>
              `).join('')}
            </div>
            <div class="scenarios">
              <div class="scenario">
                <div class="scenario-name success">‚úÖ Happy path</div>
                <div class="scenario-line">Given: []</div>
                ${cmdEl ? `<div class="scenario-line">When: ${cmdEl.name}</div>` : ''}
                <div class="scenario-line">Then: ${evtEl?.name || rmEl?.name || '...'}</div>
              </div>
              <div class="add-scenario">+ Add Scenario</div>
            </div>
          </div>
        `;
      }).join('');

      // Render loose elements
      const looseElements = elements.filter(el => !slicedElementIds.has(el.id));
      html += looseElements.map(el => {
        // Find connections for this element
        const connectionsFrom = state.connections.filter(c => c.from === el.id);
        const connectionsTo = state.connections.filter(c => c.to === el.id);
        
        const connectionLabels = {
          producer: 'produces',
          consumer: 'updates',
          trigger: 'triggers',
          invokes: 'invokes',
          input: 'triggered by',
          display: 'displayed on',
          produces: 'produces',
          updatedBy: 'updated by',
          triggers: 'triggers',
          displays: 'displays',
          context: 'uses context'
        };
        
        let connectionsHtml = '';
        
        // Outgoing connections
        connectionsFrom.forEach(conn => {
          const targetEl = state.elements[conn.to];
          if (targetEl) {
            connectionsHtml += `
              <div class="connection-item">
                <span class="connection-label">${connectionLabels[conn.relation] || conn.relation}:</span>
                <div class="connection-icon" style="background: var(--${targetEl.type}); color: ${targetEl.type === 'command' || targetEl.type === 'processor' ? '#fff' : '#000'};">${typeIcons[targetEl.type]}</div>
                <span class="connection-name">${targetEl.name}</span>
              </div>
            `;
          }
        });
        
        // Incoming connections
        connectionsTo.forEach(conn => {
          const sourceEl = state.elements[conn.from];
          if (sourceEl) {
            const reverseLabels = {
              producer: 'produced by',
              consumer: 'updated by',
              trigger: 'triggered by',
              invokes: 'invoked by',
              produces: 'produced by'
            };
            connectionsHtml += `
              <div class="connection-item">
                <span class="connection-label">${reverseLabels[conn.relation] || 'from'}:</span>
                <div class="connection-icon" style="background: var(--${sourceEl.type}); color: ${sourceEl.type === 'command' || sourceEl.type === 'processor' ? '#fff' : '#000'};">${typeIcons[sourceEl.type]}</div>
                <span class="connection-name">${sourceEl.name}</span>
              </div>
            `;
          }
        });
        
        return `
          <div class="element-card" data-id="${el.id}">
            <div class="element-header" onclick="toggleElement('${el.id}')">
              <div class="element-icon ${el.type}">${typeIcons[el.type]}</div>
              <div class="element-info">
                <div class="element-name">${el.name}</div>
                <div class="element-type">${typeLabels[el.type]}</div>
              </div>
              <div class="element-chevron">‚ñº</div>
            </div>
            ${connectionsHtml ? `<div class="element-connections">${connectionsHtml}</div>` : ''}
            <div class="element-properties">
              ${el.properties.length ? el.properties.map(p => `<div class="property">${p.name}</div>`).join('') : '<div class="property" style="font-style: italic;">No properties yet</div>'}
              <div class="add-property">+ Add property</div>
            </div>
            <div class="element-actions">
              ${elementActions[el.type].map(action => `
                <button class="action-btn" onclick="showActions('${el.id}', event)">${action.label}</button>
              `).join('')}
            </div>
          </div>
        `;
      }).join('');

      feed.innerHTML = document.getElementById('emptyState').outerHTML + html;
    }

    // ===========================================
    // INIT
    // ===========================================
    
    document.getElementById('fab').onclick = () => showSheet('createSheet');
    
    document.querySelectorAll('.sheet-overlay').forEach(overlay => {
      overlay.onclick = (e) => { if (e.target === overlay) hideAllSheets(); };
    });

    document.getElementById('elementNameInput').onkeydown = (e) => {
      if (e.key === 'Enter') dispatchCreateElement();
    };
    document.getElementById('sliceNameInput').onkeydown = (e) => {
      if (e.key === 'Enter') dispatchNameSlice();
    };

    // Load and render
    loadEventStream();
    render();
  </script>
</body>
</html>
