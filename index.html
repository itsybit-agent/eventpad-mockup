<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>EventPad MVP</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    
    :root {
      --bg: #0f0f13;
      --surface: #1a1a24;
      --surface-hover: #252532;
      --border: #2a2a3a;
      --text: #ffffff;
      --text-muted: #888;
      --event: #ff9d48;
      --command: #4a90d9;
      --readmodel: #8bc34a;
      --screen: #e0e0e0;
      --processor: #9c27b0;
      --accent: #9b59b6;
    }
    
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: var(--bg);
      color: var(--text);
      min-height: 100vh;
      padding-bottom: 80px;
    }
    
    /* Header */
    .header {
      position: sticky;
      top: 0;
      background: var(--surface);
      padding: 12px 20px;
      border-bottom: 1px solid var(--border);
      z-index: 100;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .header h1 { font-size: 18px; font-weight: 600; }
    .header-actions { display: flex; gap: 8px; }
    .header-btn {
      background: var(--surface-hover);
      border: 1px solid var(--border);
      color: var(--text);
      padding: 6px 12px;
      border-radius: 6px;
      font-size: 12px;
      cursor: pointer;
    }
    .header-btn:hover { background: var(--accent); border-color: var(--accent); }
    .header-btn:disabled { opacity: 0.3; cursor: not-allowed; }
    
    /* Event Log Toggle */
    .event-log-toggle {
      position: fixed;
      top: 60px;
      right: 16px;
      background: var(--surface);
      border: 1px solid var(--border);
      padding: 8px 12px;
      border-radius: 8px;
      font-size: 11px;
      color: var(--text-muted);
      cursor: pointer;
      z-index: 99;
    }
    
    /* Event Log Panel */
    .event-log {
      display: none;
      position: fixed;
      top: 100px;
      right: 16px;
      width: 320px;
      max-height: 60vh;
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 12px;
      overflow: hidden;
      z-index: 98;
    }
    .event-log.visible { display: block; }
    .event-log-header {
      padding: 12px;
      background: var(--bg);
      font-weight: 600;
      font-size: 13px;
      border-bottom: 1px solid var(--border);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .event-log-list {
      max-height: 50vh;
      overflow-y: auto;
      font-size: 11px;
      font-family: 'Monaco', 'Menlo', monospace;
    }
    .event-log-item {
      padding: 8px 12px;
      border-bottom: 1px solid var(--border);
      cursor: pointer;
      transition: background 0.2s;
    }
    .event-log-item:hover { background: var(--surface-hover); }
    .event-log-item:active { background: var(--accent); }
    .event-log-item:last-child { border-bottom: none; }
    .event-log-item .copied {
      color: var(--accent);
      font-size: 10px;
      margin-left: 8px;
    }
    .event-log-type { color: var(--event); font-weight: 600; }
    .event-log-data { color: var(--text-muted); margin-top: 4px; white-space: pre-wrap; word-break: break-all; }
    .event-log-time { color: var(--text-muted); font-size: 10px; }
    
    /* Feed */
    .feed {
      padding: 16px;
      padding-top: 8px;
      display: flex;
      flex-direction: column;
      gap: 16px;
    }
    
    /* Element Card */
    .element-card {
      background: var(--surface);
      border-radius: 12px;
      overflow: hidden;
      border: 1px solid var(--border);
    }
    
    .element-header {
      display: flex;
      align-items: center;
      padding: 14px 16px;
      gap: 12px;
      cursor: pointer;
    }
    .element-header:hover { background: var(--surface-hover); }
    
    .element-icon {
      width: 36px;
      height: 36px;
      border-radius: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 18px;
      flex-shrink: 0;
    }
    .element-icon.event { background: var(--event); color: #000; }
    .element-icon.command { background: var(--command); color: #fff; }
    .element-icon.readModel { background: var(--readmodel); color: #000; }
    .element-icon.screen { background: var(--screen); color: #000; }
    .element-icon.processor { background: var(--processor); color: #fff; }
    
    .element-info { flex: 1; }
    .element-name { font-weight: 600; font-size: 15px; }
    .element-type { font-size: 12px; color: var(--text-muted); }
    
    .element-chevron {
      color: var(--text-muted);
      transition: transform 0.2s;
    }
    .element-card.expanded .element-chevron { transform: rotate(180deg); }
    
    /* Connections */
    .element-connections {
      padding: 0 16px 12px;
      font-size: 12px;
    }
    .connection-item {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 6px 10px;
      background: var(--bg);
      border-radius: 8px;
      margin-bottom: 6px;
    }
    .connection-icon {
      width: 20px;
      height: 20px;
      border-radius: 4px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 11px;
    }
    .connection-label {
      color: var(--text-muted);
      font-size: 11px;
    }
    .connection-name {
      color: var(--text);
    }

    /* Properties */
    .element-properties {
      display: none;
      padding: 0 16px 12px;
      font-size: 13px;
    }
    .element-card.expanded .element-properties { display: block; }
    .property {
      padding: 6px 0;
      color: var(--text-muted);
      border-bottom: 1px solid var(--border);
    }
    .property:last-child { border-bottom: none; }
    .add-property {
      color: var(--accent);
      padding: 8px 0;
      cursor: pointer;
    }
    
    /* Actions */
    .element-actions {
      display: none;
      padding: 12px 16px;
      background: var(--bg);
      border-top: 1px solid var(--border);
      gap: 8px;
      flex-wrap: wrap;
    }
    .element-card.expanded .element-actions { display: flex; }
    
    .action-btn {
      background: var(--surface-hover);
      border: 1px solid var(--border);
      color: var(--text);
      padding: 10px 14px;
      border-radius: 20px;
      font-size: 13px;
      cursor: pointer;
      white-space: nowrap;
    }
    .action-btn:hover { background: var(--accent); border-color: var(--accent); }
    
    /* Slice Card */
    .slice-card {
      background: var(--surface);
      border-radius: 12px;
      border: 2px solid var(--accent);
      overflow: hidden;
    }
    .slice-header {
      background: var(--accent);
      color: white;
      padding: 12px 16px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .slice-name { font-weight: 600; font-size: 15px; }
    .slice-type {
      font-size: 11px;
      background: rgba(255,255,255,0.2);
      padding: 3px 8px;
      border-radius: 10px;
    }
    .slice-elements { padding: 12px; }
    .slice-element {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 8px 0;
    }
    .slice-row {
      display: flex;
      gap: 16px;
      flex-wrap: wrap;
      justify-content: center;
    }
    .slice-link {
      cursor: pointer;
      opacity: 0.9;
      transition: opacity 0.2s;
    }
    .slice-link:active {
      opacity: 0.6;
    }
    .link-indicator {
      font-size: 12px;
      color: var(--text-muted);
      margin-left: 2px;
    }
    .slice-element-icon {
      width: 28px;
      height: 28px;
      border-radius: 6px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
    }
    .slice-arrow {
      text-align: center;
      color: var(--text-muted);
      font-size: 12px;
      padding: 4px 0;
    }
    
    /* Scenarios */
    .scenarios {
      border-top: 1px solid var(--border);
      padding: 12px;
    }
    .scenario {
      background: var(--bg);
      border-radius: 8px;
      padding: 12px;
      margin-bottom: 8px;
      font-size: 13px;
    }
    .scenario-name {
      font-weight: 600;
      margin-bottom: 8px;
      display: flex;
      align-items: center;
      gap: 6px;
    }
    .scenario-name.success { color: #4caf50; }
    .scenario-line {
      color: var(--text-muted);
      padding: 2px 0;
      font-family: monospace;
      font-size: 12px;
    }
    .add-scenario {
      color: var(--accent);
      padding: 8px;
      cursor: pointer;
      text-align: center;
      font-size: 13px;
    }
    
    /* FAB */
    .fab {
      position: fixed;
      bottom: 24px;
      right: 24px;
      width: 56px;
      height: 56px;
      background: var(--accent);
      border-radius: 28px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 28px;
      color: white;
      cursor: pointer;
      box-shadow: 0 4px 12px rgba(0,0,0,0.4);
      z-index: 200;
    }
    .fab:hover { transform: scale(1.05); }
    
    /* Bottom Sheet */
    .sheet-overlay {
      display: none;
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.6);
      z-index: 300;
    }
    .sheet-overlay.active { display: block; }
    
    .sheet {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      background: var(--surface);
      border-radius: 20px 20px 0 0;
      padding: 20px;
      transform: translateY(100%);
      transition: transform 0.3s ease;
      z-index: 301;
      max-height: 80vh;
      overflow-y: auto;
    }
    .sheet-overlay.active .sheet { transform: translateY(0); }
    
    .sheet-handle {
      width: 40px;
      height: 4px;
      background: var(--border);
      border-radius: 2px;
      margin: 0 auto 16px;
    }
    .sheet-title {
      font-size: 18px;
      font-weight: 600;
      margin-bottom: 16px;
    }
    
    .sheet-options {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    .sheet-option {
      display: flex;
      align-items: center;
      gap: 14px;
      padding: 14px;
      background: var(--bg);
      border-radius: 12px;
      cursor: pointer;
    }
    .sheet-option:hover { background: var(--surface-hover); }
    .sheet-option-icon {
      width: 44px;
      height: 44px;
      border-radius: 10px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 20px;
    }
    .sheet-option-text { flex: 1; }
    .sheet-option-title { font-weight: 500; margin-bottom: 2px; }
    .sheet-option-desc { font-size: 12px; color: var(--text-muted); }
    
    .sheet-input {
      width: 100%;
      background: var(--bg);
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 14px;
      color: var(--text);
      font-size: 16px;
      margin-bottom: 16px;
    }
    .sheet-input:focus { outline: none; border-color: var(--accent); }
    .sheet-btn {
      width: 100%;
      background: var(--accent);
      color: white;
      border: none;
      padding: 14px;
      border-radius: 10px;
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
    }
    
    /* Toast */
    .toast {
      position: fixed;
      bottom: 100px;
      left: 50%;
      transform: translateX(-50%) translateY(100px);
      background: var(--surface);
      border: 1px solid var(--accent);
      padding: 12px 20px;
      border-radius: 25px;
      font-size: 14px;
      opacity: 0;
      transition: all 0.3s;
      z-index: 400;
    }
    .toast.show { transform: translateX(-50%) translateY(0); opacity: 1; }
    
    /* Empty State */
    .empty-state {
      text-align: center;
      padding: 60px 20px;
      color: var(--text-muted);
    }
    .empty-state-icon { font-size: 48px; margin-bottom: 16px; }
    .empty-state-text { font-size: 15px; }
  </style>
</head>
<body>
  <div class="header">
    <h1>EventPad</h1>
    <div class="header-actions">
      <button class="header-btn" id="undoBtn" onclick="undo()" disabled>‚Ü∂ Undo</button>
      <button class="header-btn" onclick="clearAll()">Clear</button>
    </div>
  </div>

  <div class="event-log-toggle" onclick="toggleEventLog()">
    üìã Events (<span id="eventCount">0</span>)
  </div>
  
  <div class="event-log" id="eventLog">
    <div class="event-log-header">
      <span>Event Stream</span>
      <button class="header-btn" onclick="copyAllEvents()" style="padding: 4px 8px; font-size: 11px;">Copy All</button>
    </div>
    <div class="event-log-list" id="eventLogList"></div>
  </div>

  <div class="feed" id="feed">
    <div class="empty-state" id="emptyState">
      <div class="empty-state-icon">üüß</div>
      <div class="empty-state-text">Tap + to create your first element</div>
    </div>
  </div>

  <div class="fab" id="fab">+</div>

  <!-- Create Element Sheet -->
  <div class="sheet-overlay" id="createSheet">
    <div class="sheet">
      <div class="sheet-handle"></div>
      <div class="sheet-title">Create Element</div>
      <div class="sheet-options">
        <div class="sheet-option" onclick="selectType('event')">
          <div class="sheet-option-icon" style="background: var(--event); color: #000;">üüß</div>
          <div class="sheet-option-text">
            <div class="sheet-option-title">Event</div>
            <div class="sheet-option-desc">Something that happened</div>
          </div>
        </div>
        <div class="sheet-option" onclick="selectType('command')">
          <div class="sheet-option-icon" style="background: var(--command); color: #fff;">üü¶</div>
          <div class="sheet-option-text">
            <div class="sheet-option-title">Command</div>
            <div class="sheet-option-desc">An action to perform</div>
          </div>
        </div>
        <div class="sheet-option" onclick="selectType('readModel')">
          <div class="sheet-option-icon" style="background: var(--readmodel); color: #000;">üü©</div>
          <div class="sheet-option-text">
            <div class="sheet-option-title">Read Model</div>
            <div class="sheet-option-desc">Data for display</div>
          </div>
        </div>
        <div class="sheet-option" onclick="selectType('screen')">
          <div class="sheet-option-icon" style="background: var(--screen); color: #000;">‚èπÔ∏è</div>
          <div class="sheet-option-text">
            <div class="sheet-option-title">Screen</div>
            <div class="sheet-option-desc">User interface</div>
          </div>
        </div>
        <div class="sheet-option" onclick="selectType('processor')">
          <div class="sheet-option-icon" style="background: var(--processor); color: #fff;">‚öôÔ∏è</div>
          <div class="sheet-option-text">
            <div class="sheet-option-title">Processor</div>
            <div class="sheet-option-desc">Automation logic</div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Name Element Sheet -->
  <div class="sheet-overlay" id="nameSheet">
    <div class="sheet">
      <div class="sheet-handle"></div>
      <div class="sheet-title" id="nameSheetTitle">Name your Event</div>
      <input type="text" class="sheet-input" id="elementNameInput" placeholder="e.g. OrderCreated">
      <button class="sheet-btn" onclick="dispatchCreateElement()">Create</button>
    </div>
  </div>

  <!-- Action Sheet -->
  <div class="sheet-overlay" id="actionSheet">
    <div class="sheet">
      <div class="sheet-handle"></div>
      <div class="sheet-title" id="actionSheetTitle">Connect Element</div>
      <div class="sheet-options" id="actionOptions"></div>
    </div>
  </div>

  <!-- Element Picker Sheet (for picking existing elements) -->
  <div class="sheet-overlay" id="pickerSheet">
    <div class="sheet">
      <div class="sheet-handle"></div>
      <div class="sheet-title" id="pickerSheetTitle">Pick Command</div>
      <div class="sheet-options" id="pickerOptions"></div>
      <div style="text-align: center; padding: 12px; color: var(--text-muted); font-size: 13px;" id="pickerEmpty">No elements available</div>
    </div>
  </div>

  <!-- Name Slice Sheet -->
  <div class="sheet-overlay" id="sliceNameSheet">
    <div class="sheet">
      <div class="sheet-handle"></div>
      <div class="sheet-title">üéâ Pattern detected!</div>
      <p style="color: var(--text-muted); margin-bottom: 16px; font-size: 14px;" id="slicePatternDesc"></p>
      <input type="text" class="sheet-input" id="sliceNameInput" placeholder="e.g. Create Order">
      <button class="sheet-btn" onclick="dispatchNameSlice()">Save Slice</button>
      <div style="text-align: center; padding: 12px; color: var(--text-muted); cursor: pointer;" onclick="dismissSlicePrompt()">Skip for now</div>
    </div>
  </div>

  <div class="toast" id="toast"></div>

  <script>
    // ===========================================
    // EVENT STORE
    // ===========================================
    
    const EventTypes = {
      // Element events
      ElementCreated: 'ElementCreated',
      ElementDeleted: 'ElementDeleted',
      PropertyAdded: 'PropertyAdded',
      PropertyRemoved: 'PropertyRemoved',
      
      // Connection events
      ProducerSet: 'ProducerSet',
      ConsumerAdded: 'ConsumerAdded',
      TriggerSet: 'TriggerSet',
      ProcessorOutputSet: 'ProcessorOutputSet',
      InputScreenSet: 'InputScreenSet',
      DisplayScreenSet: 'DisplayScreenSet',
      
      // Slice events
      SliceInferred: 'SliceInferred',
      SliceNamed: 'SliceNamed',
      SliceDeleted: 'SliceDeleted',
      
      // Scenario events
      ScenarioAdded: 'ScenarioAdded',
      GivenSet: 'GivenSet',
      WhenSet: 'WhenSet',
      ThenSet: 'ThenSet'
    };

    // Event stream (source of truth)
    let eventStream = [];
    
    // Load from localStorage
    function loadEventStream() {
      const saved = localStorage.getItem('eventpad_events');
      if (saved) {
        eventStream = JSON.parse(saved);
      }
    }
    
    // Save to localStorage
    function saveEventStream() {
      localStorage.setItem('eventpad_events', JSON.stringify(eventStream));
    }
    
    // Append event to stream
    function appendEvent(type, data) {
      const event = {
        id: 'evt_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9),
        type,
        data,
        timestamp: new Date().toISOString()
      };
      eventStream.push(event);
      saveEventStream();
      console.log('üìå Event:', type, data);
      return event;
    }

    // ===========================================
    // PROJECTIONS (Read Models)
    // ===========================================
    
    // Element ordering hierarchy (top to bottom)
    // Screens/Processors ‚Üí Commands/ReadModels ‚Üí Events
    function getElementOrder(elementType) {
      const order = {
        'screen': 1,
        'processor': 1,
        'command': 2,
        'readModel': 3,
        'event': 4
      };
      return order[elementType] || 5;
    }

    function sortSliceElements(elements, state) {
      return [...elements].sort((a, b) => {
        const typeA = state.elements[a]?.type;
        const typeB = state.elements[b]?.type;
        return getElementOrder(typeA) - getElementOrder(typeB);
      });
    }

    function projectState() {
      const state = {
        elements: {},      // id -> element
        slices: {},        // id -> slice
        connections: [],   // { from, to, relation }
        pendingSlice: null
      };

      for (const event of eventStream) {
        switch (event.type) {
          case EventTypes.ElementCreated:
            state.elements[event.data.elementId] = {
              id: event.data.elementId,
              type: event.data.elementType,
              name: event.data.name,
              properties: []
            };
            break;
            
          case EventTypes.ElementDeleted:
            delete state.elements[event.data.elementId];
            break;
            
          case EventTypes.PropertyAdded:
            if (state.elements[event.data.elementId]) {
              state.elements[event.data.elementId].properties.push({
                id: event.data.propertyId,
                name: event.data.name,
                type: event.data.propertyType
              });
            }
            break;
            
          case EventTypes.ProducerSet:
          case EventTypes.ConsumerAdded:
          case EventTypes.TriggerSet:
          case EventTypes.ProcessorOutputSet:
          case EventTypes.InputScreenSet:
          case EventTypes.DisplayScreenSet:
            state.connections.push({
              from: event.data.fromId,
              to: event.data.toId,
              relation: event.data.relation
            });
            break;
            
          case EventTypes.SliceInferred:
            state.slices[event.data.sliceId] = {
              id: event.data.sliceId,
              type: event.data.sliceType,
              elements: sortSliceElements(event.data.elements, state),
              name: null,
              complete: event.data.complete
            };
            if (!event.data.complete || !state.slices[event.data.sliceId].name) {
              state.pendingSlice = event.data.sliceId;
            }
            break;
            
          case EventTypes.SliceNamed:
            if (state.slices[event.data.sliceId]) {
              state.slices[event.data.sliceId].name = event.data.name;
              if (state.pendingSlice === event.data.sliceId) {
                state.pendingSlice = null;
              }
            }
            break;
          
          case 'SliceElementAdded':
            if (state.slices[event.data.sliceId]) {
              const slice = state.slices[event.data.sliceId];
              // Add element and re-sort by type hierarchy
              slice.elements.push(event.data.elementId);
              slice.elements = sortSliceElements(slice.elements, state);
            }
            break;
            
          case EventTypes.SliceDeleted:
            delete state.slices[event.data.sliceId];
            break;
          
          case 'SliceCompleted':
            if (state.slices[event.data.sliceId]) {
              state.slices[event.data.sliceId].complete = true;
            }
            break;
        }
      }

      return state;
    }

    // ===========================================
    // COMMAND HANDLERS
    // ===========================================
    
    let selectedType = null;
    let selectedElement = null;
    let pendingSliceId = null;

    const typeIcons = {
      event: 'üüß', command: 'üü¶', readModel: 'üü©', screen: '‚èπÔ∏è', processor: '‚öôÔ∏è'
    };
    const typeLabels = {
      event: 'Event', command: 'Command', readModel: 'Read Model', screen: 'Screen', processor: 'Processor'
    };

    const elementActions = {
      event: [
        { label: 'What produces this?', target: 'command', relation: 'producer', sliceType: 'SC' },
        { label: 'What does this update?', target: 'readModel', relation: 'consumer', sliceType: 'SV' }
      ],
      command: [
        { label: 'What screen triggers this?', target: 'screen', relation: 'input' },
        { label: 'What events does this produce?', target: 'event', relation: 'produces', sliceType: 'SC' }
      ],
      readModel: [
        { label: 'What events update this?', target: 'event', relation: 'updatedBy', sliceType: 'SV' },
        { label: 'What screen displays this?', target: 'screen', relation: 'display' }
      ],
      processor: [
        { label: 'What triggers this?', target: 'event', relation: 'trigger', svPicker: true },
        { label: 'What additional context?', target: 'readModel', relation: 'context', picker: true },
        { label: 'What command does this invoke?', target: 'command', relation: 'invokes', picker: true }
      ],
      screen: [
        { label: 'What command does this trigger?', target: 'command', relation: 'triggers' },
        { label: 'What does this display?', target: 'readModel', relation: 'displays' }
      ]
    };

    function dispatchCreateElement() {
      const name = document.getElementById('elementNameInput').value.trim();
      if (!name) return;

      const elementId = 'el_' + Date.now();
      
      // Emit event
      appendEvent(EventTypes.ElementCreated, {
        elementId,
        elementType: selectedType,
        name
      });

      hideAllSheets();
      showToast(`${typeLabels[selectedType]} created!`);
      render();
    }

    function dispatchConnection(relation, targetType, sliceType) {
      hideAllSheets();
      
      const name = prompt(`Name the ${typeLabels[targetType]}:`);
      if (!name) return;

      const newElementId = 'el_' + Date.now();
      
      // 1. Create the new element
      appendEvent(EventTypes.ElementCreated, {
        elementId: newElementId,
        elementType: targetType,
        name
      });

      // 2. Create connection
      const fromId = (relation === 'producer' || relation === 'trigger') ? newElementId : selectedElement.id;
      const toId = (relation === 'producer' || relation === 'trigger') ? selectedElement.id : newElementId;
      
      appendEvent(EventTypes.ProducerSet, {
        fromId,
        toId,
        relation
      });

      // 3. Check if selected element is already in a slice
      const state = projectState();
      const existingSlice = Object.values(state.slices).find(s => 
        s.elements.includes(selectedElement.id)
      );
      
      if (existingSlice) {
        // Add new element to existing slice
        let position = 'end';
        
        // Screens go at start (input) or end (display)
        if (targetType === 'screen' && relation === 'input') {
          position = 'start';
        } else if (targetType === 'readModel') {
          position = 'end';
        } else if (targetType === 'event' && relation === 'produces') {
          // Find position after command
          const cmdIndex = existingSlice.elements.findIndex(id => 
            state.elements[id]?.type === 'command'
          );
          position = cmdIndex >= 0 ? 'afterCommand' : 'end';
        }
        
        appendEvent('SliceElementAdded', {
          sliceId: existingSlice.id,
          elementId: newElementId,
          position
        });
        
        showToast('Added to slice!');
      } else if (sliceType) {
        // 4. Infer new slice if pattern detected
        const sliceId = 'slice_' + Date.now();
        let elements = [];
        let commandId = null;
        let eventId = null;
        
        if (sliceType === 'SC') {
          // SC: command -> event (order matters for display)
          if (relation === 'producer') {
            // Event asked "what produces this?" ‚Üí new command, then event
            commandId = newElementId;
            eventId = selectedElement.id;
          } else if (relation === 'produces') {
            // Command asked "what does this produce?" ‚Üí command, then new event
            commandId = selectedElement.id;
            eventId = newElementId;
          }
          
          // Check for pre-connected elements (screens at start, readModels at end)
          const inputScreens = state.connections
            .filter(c => c.from === commandId && c.relation === 'input')
            .map(c => c.to)
            .filter(id => state.elements[id]?.type === 'screen');
          
          const outputReadModels = state.connections
            .filter(c => c.from === eventId && c.relation === 'consumer')
            .map(c => c.to)
            .filter(id => state.elements[id]?.type === 'readModel');
          
          // Build elements array: [screens..., command, event, readModels...]
          elements = [...inputScreens, commandId, eventId, ...outputReadModels];
          
        } else if (sliceType === 'SV') {
          // SV: events -> readModel (events at start, readModel at end)
          let eventIds = [];
          let readModelId = null;
          
          if (relation === 'consumer') {
            // Event asked "what does this update?" ‚Üí event, then new readModel
            eventIds = [selectedElement.id];
            readModelId = newElementId;
          } else if (relation === 'updatedBy') {
            // ReadModel asked "what events update this?" ‚Üí new event, then readModel
            eventIds = [newElementId];
            readModelId = selectedElement.id;
          }
          
          // Check for pre-connected events (other events that update this readModel)
          const otherEvents = state.connections
            .filter(c => c.to === readModelId && (c.relation === 'consumer' || c.relation === 'updatedBy'))
            .map(c => c.from)
            .filter(id => state.elements[id]?.type === 'event' && !eventIds.includes(id));
          
          // Check for pre-connected display screen
          const displayScreens = state.connections
            .filter(c => c.from === readModelId && c.relation === 'display')
            .map(c => c.to)
            .filter(id => state.elements[id]?.type === 'screen');
          
          // Build elements array: [screens..., readModel, events...]
          // Screen at top (what user sees), readModel, then events (what updates it)
          elements = [...displayScreens, readModelId, ...otherEvents, ...eventIds];
          
        } else if (sliceType === 'AU') {
          elements = [selectedElement.id, newElementId]; // event -> processor
        }

        appendEvent(EventTypes.SliceInferred, {
          sliceId,
          sliceType,
          elements,
          complete: sliceType !== 'AU' // AU needs more elements
        });

        pendingSliceId = sliceId;
        
        // Show naming prompt
        document.getElementById('slicePatternDesc').textContent = 
          sliceType === 'SC' ? 'Command ‚Üí Event forms a State Change slice' :
          sliceType === 'SV' ? 'Event ‚Üí Read Model forms a State View slice' :
          'Event ‚Üí Processor starts an Automation slice';
        document.getElementById('sliceNameInput').value = '';
        
        setTimeout(() => {
          showSheet('sliceNameSheet');
          setTimeout(() => document.getElementById('sliceNameInput').focus(), 300);
        }, 300);
      }

      showToast(`${typeLabels[targetType]} connected!`);
      render();
    }

    function dispatchNameSlice() {
      const name = document.getElementById('sliceNameInput').value.trim();
      if (!name || !pendingSliceId) return;

      appendEvent(EventTypes.SliceNamed, {
        sliceId: pendingSliceId,
        name
      });

      pendingSliceId = null;
      hideAllSheets();
      showToast('Slice saved! üéâ');
      render();
    }

    function undo() {
      if (eventStream.length === 0) return;
      eventStream.pop();
      saveEventStream();
      render();
      showToast('Undone');
    }

    function clearAll() {
      if (!confirm('Clear all events?')) return;
      eventStream = [];
      saveEventStream();
      render();
      showToast('Cleared');
    }

    // ===========================================
    // UI HELPERS
    // ===========================================
    
    function showSheet(id) {
      document.getElementById(id).classList.add('active');
    }

    function hideSheet(id) {
      document.getElementById(id).classList.remove('active');
    }

    function hideAllSheets() {
      document.querySelectorAll('.sheet-overlay').forEach(s => s.classList.remove('active'));
    }

    function showToast(message) {
      const toast = document.getElementById('toast');
      toast.textContent = message;
      toast.classList.add('show');
      setTimeout(() => toast.classList.remove('show'), 2500);
    }

    function toggleEventLog() {
      document.getElementById('eventLog').classList.toggle('visible');
    }

    async function copyEvent(index, element) {
      const evt = eventStream[index];
      const text = JSON.stringify(evt, null, 2);
      
      try {
        await navigator.clipboard.writeText(text);
        
        // Show feedback
        const existing = element.querySelector('.copied');
        if (existing) existing.remove();
        
        const badge = document.createElement('span');
        badge.className = 'copied';
        badge.textContent = '‚úì copied';
        element.querySelector('.event-log-type').after(badge);
        
        setTimeout(() => badge.remove(), 1500);
      } catch (err) {
        showToast('Failed to copy');
      }
    }
    
    async function copyAllEvents() {
      const text = JSON.stringify(eventStream, null, 2);
      try {
        await navigator.clipboard.writeText(text);
        showToast('All events copied!');
      } catch (err) {
        showToast('Failed to copy');
      }
    }

    function selectType(type) {
      selectedType = type;
      hideSheet('createSheet');
      document.getElementById('nameSheetTitle').textContent = `Name your ${typeLabels[type]}`;
      document.getElementById('elementNameInput').value = '';
      showSheet('nameSheet');
      setTimeout(() => document.getElementById('elementNameInput').focus(), 300);
    }

    function toggleElement(id) {
      const card = document.querySelector(`[data-id="${id}"]`);
      card.classList.toggle('expanded');
    }

    function showActions(id, e) {
      e.stopPropagation();
      const state = projectState();
      selectedElement = state.elements[id];
      let actions = elementActions[selectedElement.type] || [];
      
      // Context-aware filtering for processors
      if (selectedElement.type === 'processor') {
        const inSlice = Object.values(state.slices).find(s => 
          s.elements.includes(selectedElement.id) && s.type === 'AU'
        );
        
        if (inSlice) {
          // Already in AU slice - no more actions needed
          actions = [];
        } else {
          // Check if trigger is set (but not yet in slice)
          const hasTrigger = state.connections.some(c => 
            c.to === selectedElement.id && c.relation === 'trigger'
          );
          
          if (hasTrigger) {
            // Has trigger, show "What additional context?" + "What command?"
            actions = actions.filter(a => a.relation === 'context' || a.relation === 'invokes');
          } else {
            // No trigger yet, only show "What triggers?"
            actions = actions.filter(a => a.relation === 'trigger');
          }
        }
      }
      
      if (actions.length === 0) {
        showToast('No actions available');
        return;
      }
      
      document.getElementById('actionSheetTitle').textContent = selectedElement.name;
      document.getElementById('actionOptions').innerHTML = actions.map(action => {
        let onclick;
        let desc;
        if (action.svPicker) {
          onclick = `showSVPicker()`;
          desc = 'Pick from State View';
        } else if (action.picker) {
          onclick = `showPicker('${action.target}', '${action.relation}', '${action.sliceType || ''}')`;
          desc = 'Pick existing';
        } else {
          onclick = `dispatchConnection('${action.relation}', '${action.target}', '${action.sliceType || ''}')`;
          desc = 'Create new';
        }
        return `
        <div class="sheet-option" onclick="${onclick}">
          <div class="sheet-option-icon" style="background: var(--${action.target}); color: ${action.target === 'command' || action.target === 'processor' ? '#fff' : '#000'};">${typeIcons[action.target]}</div>
          <div class="sheet-option-text">
            <div class="sheet-option-title">${action.label}</div>
            <div class="sheet-option-desc">${desc} ${typeLabels[action.target]}</div>
          </div>
        </div>
      `}).join('');
      
      showSheet('actionSheet');
    }

    function dismissSlicePrompt() {
      pendingSliceId = null;
      hideAllSheets();
    }

    function promptSliceName(sliceId, currentName) {
      pendingSliceId = sliceId;
      document.getElementById('sliceNameInput').value = currentName || '';
      document.getElementById('sliceNameInput').placeholder = 'Enter slice name';
      showSheet('sliceNameSheet');
    }

    function jumpToElementSlice(elementId) {
      const state = projectState();
      
      // Find non-AU slice containing this element (the source slice)
      const sourceSlice = Object.values(state.slices).find(s => 
        s.type !== 'AU' && s.elements.includes(elementId)
      );
      
      if (sourceSlice) {
        // Scroll to the slice card
        const sliceCard = document.querySelector(`[data-slice-id="${sourceSlice.id}"]`);
        if (sliceCard) {
          sliceCard.scrollIntoView({ behavior: 'smooth', block: 'center' });
          sliceCard.style.outline = '2px solid var(--accent)';
          setTimeout(() => sliceCard.style.outline = '', 1500);
        } else {
          showToast(`Source: ${sourceSlice.name || sourceSlice.type} slice`);
        }
      } else {
        showToast('Element not in a slice');
      }
    }

    let pendingPicker = null;

    function showPicker(targetType, relation, sliceType) {
      hideAllSheets();
      
      const state = projectState();
      const availableElements = Object.values(state.elements)
        .filter(el => el.type === targetType);
      
      document.getElementById('pickerSheetTitle').textContent = `Pick ${typeLabels[targetType]}`;
      
      const pickerOptions = document.getElementById('pickerOptions');
      const pickerEmpty = document.getElementById('pickerEmpty');
      
      if (availableElements.length === 0) {
        pickerOptions.innerHTML = '';
        pickerEmpty.style.display = 'block';
      } else {
        pickerEmpty.style.display = 'none';
        pickerOptions.innerHTML = availableElements.map(el => `
          <div class="sheet-option" onclick="pickElement('${el.id}')">
            <div class="sheet-option-icon" style="background: var(--${el.type}); color: ${el.type === 'command' || el.type === 'processor' ? '#fff' : '#000'};">${typeIcons[el.type]}</div>
            <div class="sheet-option-text">
              <div class="sheet-option-title">${el.name}</div>
              <div class="sheet-option-desc">${typeLabels[el.type]}</div>
            </div>
          </div>
        `).join('');
      }
      
      pendingPicker = { targetType, relation, sliceType };
      showSheet('pickerSheet');
    }

    function pickElement(elementId) {
      if (!pendingPicker) return;
      
      const { targetType, relation, sliceType } = pendingPicker;
      const state = projectState();
      const pickedElement = state.elements[elementId];
      
      hideAllSheets();
      
      // Special case: Processor picking command - create AU slice if trigger exists
      if (selectedElement.type === 'processor' && targetType === 'command') {
        // Find trigger connection for this processor
        const triggerConn = state.connections.find(c => 
          c.to === selectedElement.id && c.relation === 'trigger'
        );
        
        if (triggerConn) {
          // Create connection to command
          appendEvent(EventTypes.ProducerSet, {
            fromId: selectedElement.id,
            toId: elementId,
            relation: 'invokes'
          });
          
          // Get the readModelId from trigger event's SV slice
          const triggerEventId = triggerConn.from;
          const svSlice = Object.values(state.slices).find(s => 
            s.type === 'SV' && s.elements.includes(triggerEventId)
          );
          const primaryReadModelId = svSlice?.elements.find(id => 
            state.elements[id]?.type === 'readModel'
          );
          
          // Get additional context ReadModels
          const contextConns = state.connections.filter(c => 
            c.from === selectedElement.id && c.relation === 'context'
          );
          const additionalReadModelIds = contextConns.map(c => c.to);
          
          // Now create complete AU slice
          const sliceId = 'slice_' + Date.now();
          const elements = [triggerEventId];
          if (primaryReadModelId) elements.push(primaryReadModelId);
          additionalReadModelIds.forEach(id => {
            if (!elements.includes(id)) elements.push(id);
          });
          elements.push(selectedElement.id, elementId); // processor, command
          
          appendEvent(EventTypes.SliceInferred, {
            sliceId,
            sliceType: 'AU',
            elements,
            complete: true
          });
          
          showToast(`AU slice created!`);
          
          // Prompt for name
          pendingSliceId = sliceId;
          setTimeout(() => {
            document.getElementById('sliceNameInput').value = '';
            document.getElementById('sliceNameInput').placeholder = `e.g. ${selectedElement.name} Automation`;
            showSheet('sliceNameSheet');
          }, 300);
          
          pendingPicker = null;
          render();
          return;
        }
      }
      
      // Default: Create connection to existing element
      const fromId = selectedElement.id;
      const toId = elementId;
      
      appendEvent(EventTypes.ProducerSet, {
        fromId,
        toId,
        relation
      });
      
      // Check if selected element is in a slice, add picked element to it
      const existingSlice = Object.values(state.slices).find(s => 
        s.elements.includes(selectedElement.id)
      );
      
      if (existingSlice) {
        appendEvent('SliceElementAdded', {
          sliceId: existingSlice.id,
          elementId: elementId
        });
        
        showToast(`${pickedElement.name} added to slice!`);
      } else {
        showToast(`Connected to ${pickedElement.name}`);
      }
      
      pendingPicker = null;
      render();
    }

    // SV Picker - shows events from existing SV slices for AU trigger
    function showSVPicker() {
      hideAllSheets();
      
      const state = projectState();
      
      // Find all SV slices
      const svSlices = Object.values(state.slices).filter(s => s.type === 'SV' && s.name);
      
      document.getElementById('pickerSheetTitle').textContent = 'Pick Trigger from State View';
      
      const pickerOptions = document.getElementById('pickerOptions');
      const pickerEmpty = document.getElementById('pickerEmpty');
      
      if (svSlices.length === 0) {
        pickerOptions.innerHTML = '';
        pickerEmpty.textContent = 'No State Views yet. Create an SV slice first (Event ‚Üí ReadModel).';
        pickerEmpty.style.display = 'block';
      } else {
        pickerEmpty.style.display = 'none';
        
        // Build options grouped by SV
        let html = '';
        svSlices.forEach(sv => {
          // Find events in this SV
          const events = sv.elements
            .map(id => state.elements[id])
            .filter(el => el && el.type === 'event');
          
          // Find readModel in this SV
          const readModel = sv.elements
            .map(id => state.elements[id])
            .find(el => el && el.type === 'readModel');
          
          if (events.length > 0 && readModel) {
            html += `<div style="padding: 8px 16px; color: var(--text-muted); font-size: 12px; text-transform: uppercase;">${sv.name}</div>`;
            events.forEach(evt => {
              html += `
                <div class="sheet-option" onclick="pickSVTrigger('${evt.id}', '${readModel.id}', '${sv.id}')">
                  <div class="sheet-option-icon" style="background: var(--event);">üüß</div>
                  <div class="sheet-option-text">
                    <div class="sheet-option-title">${evt.name}</div>
                    <div class="sheet-option-desc">+ üü© ${readModel.name} as context</div>
                  </div>
                </div>
              `;
            });
          }
        });
        
        pickerOptions.innerHTML = html || '<div style="padding: 16px; color: var(--text-muted);">No events in State Views</div>';
      }
      
      showSheet('pickerSheet');
    }

    function pickSVTrigger(eventId, readModelId, svSliceId) {
      hideAllSheets();
      
      const state = projectState();
      const processorId = selectedElement.id;
      const evt = state.elements[eventId];
      const rm = state.elements[readModelId];
      
      // Create TriggerSet connection - NO slice yet, just store trigger info
      appendEvent(EventTypes.TriggerSet, {
        fromId: eventId,
        toId: processorId,
        relation: 'trigger',
        readModelId: readModelId  // Store associated readModel for later
      });
      
      showToast(`Trigger set: ${evt.name}. Now pick a command.`);
      render();
    }

    // ===========================================
    // RENDER
    // ===========================================
    
    function renderSliceElements(elements, sliceType) {
      if (sliceType === 'AU') {
        // AU: Processor on top, ReadModels + Command on same row (no events shown)
        const processor = elements.find(e => e.type === 'processor');
        const command = elements.find(e => e.type === 'command');
        const readModels = elements.filter(e => e.type === 'readModel');
        // Events not shown - implied by linked ReadModel's SV slice
        
        let html = '';
        
        // Processor at top
        if (processor) {
          html += `
            <div class="slice-element">
              <div class="slice-element-icon" style="background: var(--processor); color: #fff;">‚öôÔ∏è</div>
              <span>${processor.name}</span>
            </div>
          `;
        }
        
        // ReadModels (left) + Command (right) on same row
        if (command || readModels.length > 0) {
          if (processor) html += '<div class="slice-arrow">‚Üì</div>';
          html += '<div class="slice-row">';
          // ReadModels first (left)
          readModels.forEach(rm => {
            html += `
              <div class="slice-element slice-link" onclick="jumpToElementSlice('${rm.id}')" title="Tap to see source slice">
                <div class="slice-element-icon" style="background: var(--readmodel); color: #000;">üü©</div>
                <span>${rm.name}</span>
                <span class="link-indicator">‚Üó</span>
              </div>
            `;
          });
          // Command (right)
          if (command) {
            html += `
              <div class="slice-element slice-link" onclick="jumpToElementSlice('${command.id}')" title="Tap to see source slice">
                <div class="slice-element-icon" style="background: var(--command); color: #fff;">üü¶</div>
                <span>${command.name}</span>
                <span class="link-indicator">‚Üó</span>
              </div>
            `;
          }
          html += '</div>';
        }
        
        return html;
      }
      
      // Default: vertical list
      return elements.map((el, i) => `
        ${i > 0 ? '<div class="slice-arrow">‚Üì</div>' : ''}
        <div class="slice-element">
          <div class="slice-element-icon" style="background: var(--${el.type}); color: ${el.type === 'command' || el.type === 'processor' ? '#fff' : '#000'};">${typeIcons[el.type]}</div>
          <span>${el.name}</span>
        </div>
      `).join('');
    }
    
    function render() {
      const state = projectState();
      const feed = document.getElementById('feed');
      
      // Update event count
      document.getElementById('eventCount').textContent = eventStream.length;
      document.getElementById('undoBtn').disabled = eventStream.length === 0;
      
      // Update event log
      document.getElementById('eventLogList').innerHTML = eventStream.slice().reverse().map((evt, i) => `
        <div class="event-log-item" onclick="copyEvent(${eventStream.length - 1 - i}, this)">
          <span class="event-log-type">${evt.type}</span>
          <span class="event-log-time">${new Date(evt.timestamp).toLocaleTimeString()}</span>
          <div class="event-log-data">${JSON.stringify(evt.data, null, 2)}</div>
        </div>
      `).join('');

      const elements = Object.values(state.elements);
      const slices = Object.values(state.slices); // Show all slices (named and unnamed)
      
      document.getElementById('emptyState').style.display = elements.length ? 'none' : 'block';

      // Get elements that are in named slices
      const slicedElementIds = new Set(slices.flatMap(s => s.elements));

      // Render slices
      let html = slices.map(slice => {
        const sliceElements = slice.elements.map(id => state.elements[id]).filter(Boolean);
        const cmdEl = sliceElements.find(e => e.type === 'command');
        const evtEl = sliceElements.find(e => e.type === 'event');
        const rmEl = sliceElements.find(e => e.type === 'readModel');
        
        return `
          <div class="slice-card" data-slice-id="${slice.id}">
            <div class="slice-header" onclick="promptSliceName('${slice.id}', '${slice.name || ''}')" style="cursor: pointer;"
              <span class="slice-name">${slice.name || '(tap to name)'}</span>
              <span class="slice-type">${slice.type}${slice.complete === false ? ' ‚è≥' : ''}</span>
            </div>
            <div class="slice-elements">
              ${renderSliceElements(sliceElements, slice.type)}
            </div>
            <div class="scenarios">
              <div class="scenario">
                <div class="scenario-name success">‚úÖ Happy path</div>
                <div class="scenario-line">Given: []</div>
                ${cmdEl ? `<div class="scenario-line">When: ${cmdEl.name}</div>` : ''}
                <div class="scenario-line">Then: ${evtEl?.name || rmEl?.name || '...'}</div>
              </div>
              <div class="add-scenario">+ Add Scenario</div>
            </div>
          </div>
        `;
      }).join('');

      // Render loose elements
      const looseElements = elements.filter(el => !slicedElementIds.has(el.id));
      html += looseElements.map(el => {
        // Find connections for this element
        const connectionsFrom = state.connections.filter(c => c.from === el.id);
        const connectionsTo = state.connections.filter(c => c.to === el.id);
        
        const connectionLabels = {
          producer: 'produces',
          consumer: 'updates',
          trigger: 'triggers',
          invokes: 'invokes',
          input: 'triggered by',
          display: 'displayed on',
          produces: 'produces',
          updatedBy: 'updated by',
          triggers: 'triggers',
          displays: 'displays',
          context: 'uses context'
        };
        
        let connectionsHtml = '';
        
        // Outgoing connections
        connectionsFrom.forEach(conn => {
          const targetEl = state.elements[conn.to];
          if (targetEl) {
            connectionsHtml += `
              <div class="connection-item">
                <span class="connection-label">${connectionLabels[conn.relation] || conn.relation}:</span>
                <div class="connection-icon" style="background: var(--${targetEl.type}); color: ${targetEl.type === 'command' || targetEl.type === 'processor' ? '#fff' : '#000'};">${typeIcons[targetEl.type]}</div>
                <span class="connection-name">${targetEl.name}</span>
              </div>
            `;
          }
        });
        
        // Incoming connections
        connectionsTo.forEach(conn => {
          const sourceEl = state.elements[conn.from];
          if (sourceEl) {
            const reverseLabels = {
              producer: 'produced by',
              consumer: 'updated by',
              trigger: 'triggered by',
              invokes: 'invoked by',
              produces: 'produced by'
            };
            connectionsHtml += `
              <div class="connection-item">
                <span class="connection-label">${reverseLabels[conn.relation] || 'from'}:</span>
                <div class="connection-icon" style="background: var(--${sourceEl.type}); color: ${sourceEl.type === 'command' || sourceEl.type === 'processor' ? '#fff' : '#000'};">${typeIcons[sourceEl.type]}</div>
                <span class="connection-name">${sourceEl.name}</span>
              </div>
            `;
          }
        });
        
        return `
          <div class="element-card" data-id="${el.id}">
            <div class="element-header" onclick="toggleElement('${el.id}')">
              <div class="element-icon ${el.type}">${typeIcons[el.type]}</div>
              <div class="element-info">
                <div class="element-name">${el.name}</div>
                <div class="element-type">${typeLabels[el.type]}</div>
              </div>
              <div class="element-chevron">‚ñº</div>
            </div>
            ${connectionsHtml ? `<div class="element-connections">${connectionsHtml}</div>` : ''}
            <div class="element-properties">
              ${el.properties.length ? el.properties.map(p => `<div class="property">${p.name}</div>`).join('') : '<div class="property" style="font-style: italic;">No properties yet</div>'}
              <div class="add-property">+ Add property</div>
            </div>
            <div class="element-actions">
              ${elementActions[el.type].map(action => `
                <button class="action-btn" onclick="showActions('${el.id}', event)">${action.label}</button>
              `).join('')}
            </div>
          </div>
        `;
      }).join('');

      feed.innerHTML = document.getElementById('emptyState').outerHTML + html;
    }

    // ===========================================
    // INIT
    // ===========================================
    
    document.getElementById('fab').onclick = () => showSheet('createSheet');
    
    document.querySelectorAll('.sheet-overlay').forEach(overlay => {
      overlay.onclick = (e) => { if (e.target === overlay) hideAllSheets(); };
    });

    document.getElementById('elementNameInput').onkeydown = (e) => {
      if (e.key === 'Enter') dispatchCreateElement();
    };
    document.getElementById('sliceNameInput').onkeydown = (e) => {
      if (e.key === 'Enter') dispatchNameSlice();
    };

    // Load and render
    loadEventStream();
    render();
  </script>
</body>
</html>
